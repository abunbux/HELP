# -*- mode: org; -*-
#+TITLE: модуль watchdog
#+DESCRIPTION:
#+KEYWORDS:
#+AUTHOR:
#+email:
#+INFOJS_OPT:
#+STARTUP:  content

#+DATE: CREATED: <Fri Jun 03 15:34:54 EEST 2022>
# Time-stamp: <Последнее обновление -- Thursday June 9 21:18:48 EEST 2022>


** Для чего нужен модуль watchdog?

   Первая строка из репозитория модуля - ~Python API and shell utilities to monitor file system
   events~ (Python API и утилиты оболочки для мониторинга событий файловой системы).

   Например:

   - Программа управления файлами для загрузки и обработки файлов, таких как изображения с SD-карты,
     или в папке ~загрузки~, например.
   - Среда разработки генератора статических сайтов следит за изменениями в исходном коде и
     перестраивает сайт при сохранении.
   - Различные задачи автоматизации дома и на рабочем месте

** Несколько полезных ссылок

   - [[https://github.com/gorakhargosh/watchdog][gorakhargosh/watchdog]] (ссылка на репозиторий разработчика на github).
   - [[https://pythonhosted.org/watchdog/index.html][watchdog 0.8.2 documentation]] (внешняя ссылка на документацию).
   - [[https://python-watchdog.readthedocs.io/en/stable/quickstart.html#a-simple-example][A Simple Example]] (внешняя ссылка на пример в документации разработчика).

   - [[https://habr.com/ru/post/140649/][Мониторинг за изменениями файловой системы]] (внешняя ссылка на habr.com).


   - [[https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c][How to Monitor File System Events in Python]] (ссылка на статью [[https://ngwaifoong92.medium.com/][Ng Wai Foong]] от Jun 8, 2020 на
     инглиш)

     и ниже ссылка на её перевод от 13.06.2021

   - [[https://nuancesprog.ru/p/12757/][Как отслеживать события файловой системы в Python]] (ссылка на nuancesprog.ru).


   - [[https://philipkiely.com/code/python_watchdog.html][Get Started with Python Watchdog]] (09 April 2021, статья на инглиш)
   - [[https://www.geeksforgeeks.org/create-a-watchdog-in-python-to-look-for-filesystem-changes/][Create a watchdog in Python to look for filesystem changes]] (06 Dec, 2019, статья на инглиш)

   И наконец видео с сопутствующими статьями:
   - [[https://www.youtube.com/watch?v=uFzNc7D44HI][Python на практике / Пишем 3 программы на Питон за 5 минут]] (ссылка на ~youtube~ + статья по этому
     видео [[https://itproger.com/news/pishem-3-programmi-na-python-za-paru-minut][Пишем 3 программы на Python за пару минут]]).


   - [[https://www.youtube.com/watch?v=6o8ck1eIReU][Python project - File Organization with Watchdog | Part-1]] (ссылка на ~youtube~ - говорят не по-нашенски),
   - [[https://www.youtube.com/watch?v=AxxZL6Qpx0c][Python Project - File organization using Watchdog | Part-2]] (вторая часть видео +
     [[https://github.com/bharath2438/Watchdog_project/blob/master/watchdog_example.py][watchdog_example.py]] пример кода на github).


   - [[https://www.youtube.com/watch?v=geCx-psFOcs][Monitor MULTIPLE folders with Python Watchdog and Multiprocessing]] (ссылка на ~youtube~ +
     [[https://github.com/bjone6/WatchdogFilesChecker][bjone6/WatchdogFilesChecker]] пример кода на github).

** Послание

   Послание ~себе~ будущему и ~тебе~, мой друг, который с некоторой долей вероятности всё-таки может
   сюда попасть и прочитать, и посмеяться с моего неумелого описания:
   Некоторые термины я сейчас, возможно, употребляю неправильно. Не суди меня строго. Мне всего лишь
   48 и я ещё только учусь.

** Установка:

   Для начала, конечно же, библиотеку нужно установить:

   #+BEGIN_SRC shell

     pip install watchdog

   #+END_SRC

** Устройство модуля:

   По сути ~watchdog~ состоит из двух частей:

   - Наблюдатель (~Observer~). Это класс, который отслеживает любое изменение файловой системы, а
     затем отправляет событие обработчику ~event handler~. Он контролирует файловую систему и ищет
     любые изменения;

   - Обработчик событий (~Event handler~). Это объект, который будет уведомлён, когда что-то случится
     с файловой системой и нужно произвести какое-либо действие, пусть даже и не с самим объектом
     наблюдения, можно просто сделать запись в журнал. Действие, понятное дело, нужно прописать в
     коде.

     И, следовательно, реализация состоит в следующем:

     - Во-первых, конечно же это импорт:

     #+BEGIN_SRC python

       from watchdog.observers import Observer
       from watchdog.events import LoggingEventHandler
       # (или FileSystemEventHandler, или PatternMatchingEventHandler, или RegexMatchingEventHandler)

     #+END_SRC

     - Определяем подкласс обработчика событий (~Event handler~) с собственной реализацией и создаём из
       него экземпляр:

     #+NAME: создание экземпляра класса FileSystemEventHandler() с собственной реализацией:
     #+BEGIN_SRC python

       from watchdog.events import FileSystemEventHandler

       class Handler(FileSystemEventHandler):
           def on_created(self, event):
               print event

           def on_deleted(self, event):
               print event

           def on_moved(self, event):
               print event

     #+END_SRC

     но справедливости ради стоит сказать, что можно обойтись и встроенной реализацией обработчика:

     #+NAME: создание экземпляра класса LoggingEventHandler() без дополнительных настроек:
     #+BEGIN_SRC python

       from watchdog.events import LoggingEventHandler
       event_handler = LoggingEventHandler()

     #+END_SRC

     - Создаём экземпляр класса потоков ~watchdog.observers.Observer~:

       #+BEGIN_SRC python

         observer = Observer()

       #+END_SRC

     - Вызываем функцию расписания через экземпляр наблюдателя (~observer.schedule()~), прикрепляя
       обработчик событий. Функция принимает несколько других входных параметров, таких как путь к
       отслеживаемому каталогу и рекурсивная работа.
       По умолчанию экземпляр ~watchdog.observers.Observer~ не будет отслеживать подкаталоги. Путем
       передачи ~recursive=True~ обеспечивается мониторинг всего дерева каталогов.

     #+NAME:
     #+BEGIN_SRC python

       observer.schedule(Handler(), path='.', recursive=True)

     #+END_SRC

     - Запускаем поток наблюдателя и ждём, пока он сгенерирует события, которые вызовут исполнение
       кода внутри обработчика событий.

     #+NAME:
     #+BEGIN_SRC python

       observer.start()

     #+END_SRC

     - После вызова ~start()~ мы получаем фоновый поток, следящий за изменениями. Нужно обеспечить
       жизненный цикл наблюдателю:

       #+BEGIN_SRC python

         try:
             while observer.is_alive():
                 observer.join(1)
         except KeyboardInterrupt:
             print('Операция завершена пользователем.')
         finally:
             observer.stop()
             observer.join()

       #+END_SRC

   - Метод ~observer.is_alive()~ возвращает жив ли поток.
   - ~observer.join(timeout=None)~ ждёт завершения потока. Это блокирует вызывающий поток до тех пор,
     пока поток, чей метод join() вызывается, не завершится - либо в обычном режиме, либо из-за
     необработанного исключения, либо до тех пор, пока не произойдет необязательный тайм-аут. Когда
     присутствует аргумент тайм-аута, а не None, он должен быть числом с плавающей запятой,
     указывающим тайм-аут для операции в секундах (или их долях). Поскольку join() всегда возвращает
     None, вы должны вызвать ~is_alive()~ после ~join()~, чтобы решить, произошел ли тайм-аут - если
     поток все еще активен, время ожидания вызова join() истекло.
     Если аргумент тайм-аута отсутствует или установлен None, операция будет заблокирована до тех пор,
     пока поток не завершится.
   - В конце нужно вызвать ~stop()~ для очистки ресурсов.

**** Обработчик событий (Event Handler)

     В настоящее время в модуле доступно 4 типа обработчиков событий:
     - ~FileSystemEventHandler~  -  базовый обработчик событий файловой системы, из которого можно
       переопределить методы;
     - ~PatternMatchingEventHandler~ - сопоставляет заданные шаблоны с путями к файлам, которые связаны с
       происходящими событиями;
     - ~RegexMatchingEventHandler~ - сопоставляет заданные регулярные выражения с путями к файлам, которые
       связаны с происходящими событиями;
     - ~LoggingEventHandler~ - регистрирует все записанные события.

       Остальные классы наследуются от ~FileSystemEventHandler~, который предоставляет для
       переопределения следующие функции:
     - ~on_any_event~ - обработчик для всех событий;
     - ~on_created~ - вызывается при создании файла или каталога;
     - ~on_deleted~ - вызывается при удалении файла или каталога;
     - ~on_modified~ - вызывается при изменении файла или каталога;
     - ~on_moved~ - вызывается при перемещении или переименовании файла или каталога.

     #+BEGIN_SRC python

       class MyHandler(FileSystemEventHandler):
           def on_any_event(self, event):
               print(event.event_type, event.src_path)

           def on_created(self, event):
               print("on_created", event.src_path)

           def on_deleted(self, event):
               print("on_deleted", event.src_path)

           def on_modified(self, event):
               print("on_modified", event.src_path)

           def on_moved(self, event):
               print("on_moved", event.src_path)

     #+END_SRC

     Принты (print) можно заменить своей логикой.

     Для каждой из функций представлен входной параметр ~event~, который содержит следующие переменные:
     - ~event_type~ - тип события в виде строки. По умолчанию значение ~None~;
     - ~is_directory~ - ~true~, если событие было выдано для каталога. В противном случае - ~false~;
     - ~src_path~ - исходный путь объекта файловой системы, вызвавшего это событие.

     Наиболее полезный параметр здесь - ~src_path~.
     Им можно воспользоваться, чтобы определить, какой файл был изменен, прежде чем запускать
     соответствующую логику.

     #+BEGIN_SRC python

       if(event.src_path == "./path/file.txt"):
           print("Execute your logic here!")

     #+END_SRC

** Пример кода из официальной документации разработчика с моими микро-правками:

   [[https://python-watchdog.readthedocs.io/en/stable/quickstart.html#a-simple-example][A Simple Example]] (внешняя ссылка на пример в документации разработчика).

   Следующий пример программы будет рекурсивно отслеживать изменения файловой системы в текущем
   каталоге и просто выводить их на консоль.

   Сразу же небольшое пояснение:

   - После запуска в первозданно-скопированном виде выдаёт

     *AttributeError: 'InotifyObserver' object has no attribute 'isAlive'*

     в документации указано - ~This method is deprecated, use is_alive() instead.~ - делаем как
     советуют и меняем ~observer.isAlive()~ на ~observer.is_alive()~;

     - Далее вместо принятия аргументов через ~sys.argv[1]~ следовало бы осуществить это, импортировав
       ~argparse~;

     - Добавил ~except KeyboardInterrupt~;

       Настроек пользователя здесь минимум, используется ~встроенный watchdog.events.LoggingEventHandler~.

       Ну, да это всего лишь пример:

       #+BEGIN_SRC python

         import sys
         import logging
         from watchdog.observers import Observer
         from watchdog.events import LoggingEventHandler

         if __name__ == "__main__":
             # Сперва идут настройки логирования модуля logging:
             logging.basicConfig(level=logging.INFO,
                                 format='%(asctime)s - %(message)s',
                                 datefmt='%Y-%m-%d %H:%M:%S')

             # Затем определение аргумента командной строки,
             # который должен принять путь к исследуемой директории.
             # Вместо этого следовало бы использовать argparse:
             path = sys.argv[1] if len(sys.argv) > 1 else '.'

             # Создаём экземпляр класса обработчика,
             # LoggingEventHandler - регистрирует все события:
             event_handler = LoggingEventHandler()

             # Создаём экземпляр класса обозревателя:
             observer = Observer()

             # Вызываем функцию расписания через экземпляр наблюдателя observer.schedule(),
             # передавая в неё экземпляр класса LoggingEventHandler(), он сопоставлен с переменной
             # event_handler, путь - path, который получаем через аргумент командной строки
             # и указываем, что наблюдать нужно рекурсивно:
             observer.schedule(event_handler, path, recursive=True)

             # Запускаем обозреватель:
             observer.start()
             try:
                 while observer.is_alive():
                     observer.join(1)
             except KeyboardInterrupt:
                 print('Операция завершена пользователем.')
             finally:
                 observer.stop()
                 observer.join()

       #+END_SRC

       Для остановки нужно нажать ~Control-c~.

***** DONE +@todo Переписать код с использованием argparse.+
      CLOSED: [2022-06-09 Thu 21:18]

      результат [[file:watchdog_of_doc.py][watchdog_of_doc.py]]

** Далее небольшой пример с Хабра:

   [[https://habr.com/ru/post/140649/][Мониторинг за изменениями файловой системы]] (внешняя ссылка).

   Здесь импортируется класс ~FileSystemEventHandler~ - базовый класс обработчика событий файловой
   системы, методы которого можно переопределить. Сам он мало, что умеет, но можно научить его
   потомка.

   #+BEGIN_SRC python

     import time
     from watchdog.observers import Observer
     from watchdog.events import FileSystemEventHandler

     class Handler(FileSystemEventHandler):
         def on_created(self, event):
             print event

         def on_deleted(self, event):
             print event

         def on_moved(self, event):
             print event


     # Запускаем это все:
     observer = Observer()
     observer.schedule(Handler(), path='.', recursive=True)
     observer.start()

     try:
         while True:
             time.sleep(0.1)
     except KeyboardInterrupt:
         observer.stop()
         observer.join()

   #+END_SRC

** Следующий пример и опять с моими микро-правками:


   Ссылка на статью [[https://ngwaifoong92.medium.com/][Ng Wai Foong]] от Jun 8, 2020 на английском языке -
   - [[https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c][How to Monitor File System Events in Python]]

     и ниже ссылка на её перевод от 13.06.2021

     - [[https://nuancesprog.ru/p/12757/][Как отслеживать события файловой системы в Python]] (ссылка на nuancesprog.ru)

     Код, взятый у автора из статьи, содержал цикл без выхода, поэтому я его немного подправил.

     #+NAME: код с сайта автора
     #+BEGIN_SRC python

       while True:
           try:
               pass
           except KeyboardInterrupt:
               observer.stop()

     #+END_SRC

     Далее код с комментариями и исправлением:

     #+BEGIN_SRC python

       from watchdog.observers import Observer
       from watchdog.events import FileSystemEventHandler

       # Создаём новый класс, который наследуется от FileSystemEventHandler:
       class MyHandler(FileSystemEventHandler):
           def on_any_event(self, event):
               print(event.event_type, event.src_path)

           def on_created(self, event):
               print("on_created", event.src_path)

           def on_deleted(self, event):
               print("on_deleted", event.src_path)

           def on_modified(self, event):
               print("on_modified", event.src_path)

           def on_moved(self, event):
               print("on_moved", event.src_path)

       # После добавления подкласса можно безопасно создать его экземпляр
       # вместе с классом Observer:
       event_handler = MyHandler()
       observer = Observer()

       # Вызываем функцию расписания через экземпляр наблюдателя observer.schedule(),
       # передавая в неё экземпляр класса FileSystemEventHandler(), он сопоставлен с переменной
       # MyHandler.
       # Назначим выбранный путь для процесса отслеживания.
       # В данном случае это текущая папка, откуда запускается скрипт,
       # И просим не работать рекурсивно:
       observer.schedule(event_handler, path='.', recursive=False)

       # Вызов «start» запустит поток, и при внесении изменений
       # в соответствующий путь будет сгенерировано событие.
       observer.start()

       # Чтобы протестировать написанный код, надо реализовать цикл выполнения
       # и предотвратить выход из него.
       # На выходе при возникновении исключения KeyboardInterrupt
       # вызываем функцию «stop» для очистки ресурсов.
       try:
           while observer.is_alive():
               observer.join()
       except KeyboardInterrupt:
           observer.stop()

     #+END_SRC

# -*- mode: org; -*-
#+TITLE: модуль watchdog
#+DESCRIPTION:
#+KEYWORDS:
#+AUTHOR:
#+email:
#+INFOJS_OPT:
#+STARTUP:  content

#+DATE: CREATED: <Fri Jun 03 15:34:54 EEST 2022>
# Time-stamp: <Последнее обновление -- Tuesday June 7 17:3:19 EEST 2022>


** Для чего нужен модуль watchdog?

   Первая строка из репозитория модуля - ~Python API and shell utilities to monitor file system
   events~ (Python API и утилиты оболочки для мониторинга событий файловой системы).

   Например:

   - Программа управления файлами для загрузки и обработки файлов, таких как изображения с SD-карты,
     или в папке ~загрузки~, например.
   - Среда разработки генератора статических сайтов следит за изменениями в исходном коде и
     перестраивает сайт при сохранении.
   - Различные задачи автоматизации дома и на рабочем месте

** Несколько полезных ссылок

   - [[https://github.com/gorakhargosh/watchdog][gorakhargosh/watchdog]] (ссылка на репозиторий разработчика на github)
   - [[https://pythonhosted.org/watchdog/index.html][watchdog 0.8.2 documentation]] (внешняя ссылка на документацию)

   - [[https://philipkiely.com/code/python_watchdog.html][Get Started with Python Watchdog]] (09 April 2021, статья на инглиш)
   - [[https://www.geeksforgeeks.org/create-a-watchdog-in-python-to-look-for-filesystem-changes/][Create a watchdog in Python to look for filesystem changes]] (06 Dec, 2019, статья на инглиш)


   И наконец видео с сопутствующей статьёй:
   - [[https://www.youtube.com/watch?v=uFzNc7D44HI][Python на практике / Пишем 3 программы на Питон за 5 минут]] (ссылка на ~youtube~ + статья по этому
     видео [[https://itproger.com/news/pishem-3-programmi-na-python-za-paru-minut][Пишем 3 программы на Python за пару минут]])

** Послание

   Послание ~себе~ будущему и ~тебе~, мой друг, который с некоторой долей вероятности всё-таки может
   сюда попасть и прочитать, и посмеяться с моего неумелого описания:
   Некоторые термины я сейчас, возможно, употребляю неправильно. Не суди меня строго. Мне всего лишь
   48 и я ещё только учусь.

** Кратенькое руководство для моей памяти

*** Установка:

    Для начала, конечно же, библиотеку нужно установить:

    #+BEGIN_SRC shell

      pip install watchdog

    #+END_SRC

*** Устройство модуля:

    По сути ~watchdog~ состоит из двух частей:

    - Наблюдатель (~Observer~). Это класс, который отслеживает любое изменение файловой системы, а
      затем отправляет событие обработчику ~event handler~. Он контролирует файловую систему и ищет
      любые изменения;

    - Обработчик событий (~Event handler~). Это объект, который будет уведомлён, когда что-то случится
      с файловой системой и нужно произвести какое-либо действие, пусть даже и не с самим объектом
      наблюдения, можно просто сделать запись в журнал. Действие, понятное дело, нужно прописать в
      коде.

    И, следовательно, реализация состоит в следующем:

    - Во-первых, конечно же это импорт:

    #+BEGIN_SRC python

      from watchdog.observers import Observer
      from watchdog.events import LoggingEventHandler
      # (или FileSystemEventHandler, или PatternMatchingEventHandler, или RegexMatchingEventHandler)

    #+END_SRC

    - Определяем подкласс обработчика событий (~Event handler~) с собственной реализацией и создаём из
      него экземпляр:

    #+NAME: создание экземпляра класса FileSystemEventHandler() с собственной реализацией:
    #+BEGIN_SRC python

      from watchdog.events import FileSystemEventHandler

      class Handler(FileSystemEventHandler):
          def on_created(self, event):
              print event

          def on_deleted(self, event):
              print event

          def on_moved(self, event):
              print event


    #+END_SRC

    но справедливости ради стоит сказать, что можно обойтись и встроенной реализацией обработчика:

    #+NAME: создание экземпляра класса LoggingEventHandler() без дополнительных настроек:
    #+BEGIN_SRC python

      from watchdog.events import LoggingEventHandler
      event_handler = LoggingEventHandler()

    #+END_SRC

    - Создаём экземпляр класса потоков ~watchdog.observers.Observer~:

      #+BEGIN_SRC python

        observer = Observer()

      #+END_SRC

    - Вызываем функцию расписания через экземпляр наблюдателя (~observer.schedule()~), прикрепляя
      обработчик событий. Функция принимает несколько других входных параметров, таких как путь к
      отслеживаемому каталогу и рекурсивная работа:

    #+NAME:
    #+BEGIN_SRC python

      observer.schedule(Handler(), path='.', recursive=True)

    #+END_SRC

    - Запускаем поток наблюдателя и ждём, пока он сгенерирует события, которые вызовут исполнение
      кода внутри обработчика событий.

    #+NAME:
    #+BEGIN_SRC python

      observer.start()

    #+END_SRC


**** Обработчик событий (Event Handler)

     В настоящее время в модуле доступно 4 типа обработчиков событий:

     - ~FileSystemEventHandler~  -  базовый обработчик событий файловой системы, из которого можно
       переопределить методы;

     - ~PatternMatchingEventHandler~ - сопоставляет заданные шаблоны с путями к файлам, которые связаны с
       происходящими событиями;

     - ~RegexMatchingEventHandler~ - сопоставляет заданные регулярные выражения с путями к файлам, которые
       связаны с происходящими событиями;

     - ~LoggingEventHandler~ - регистрирует все записанные события.

       Остальные классы наследуются от ~FileSystemEventHandler~, который предоставляет для
       переопределения следующие функции:

     - ~on_any_event~ - обработчик для всех событий;
     - ~on_created~ - вызывается при создании файла или каталога;
     - ~on_deleted~ - вызывается при удалении файла или каталога;
     - ~on_modified~ - вызывается при изменении файла или каталога;
     - ~on_moved~ - вызывается при перемещении или переименовании файла или каталога.

*** Пример кода из официальной документации разработчика с моими микро-правками:

    [[https://python-watchdog.readthedocs.io/en/stable/quickstart.html#a-simple-example][A Simple Example]] (внешняя ссылка).

    Следующий пример программы будет рекурсивно отслеживать изменения файловой системы в текущем
    каталоге и просто выводить их на консоль.

    - После запуска в первозданно-скопированном виде выдаёт

    ~AttributeError: 'InotifyObserver' object has no attribute 'isAlive'~

    копаться и разбираться не стал - в цикле ~while~ заменил ~observer.isAlive()~ на ~True~;

    - Далее вместо принятия аргументов через ~sys.argv[1]~ лучше было бы осуществить это, импортировав
      ~argparse~;

    - Добавил ~except KeyboardInterrupt:~;

      Настроек пользователя здесь минимум, используется ~встроенный watchdog.events.LoggingEventHandler~.

      Ну, да это всего лишь пример:

      #+BEGIN_SRC python

        import sys
        import logging
        from watchdog.observers import Observer
        from watchdog.events import LoggingEventHandler

        if __name__ == "__main__":
            # Сперва идут настройки логирования модуля logging:
            logging.basicConfig(level=logging.INFO,
                                format='%(asctime)s - %(message)s',
                                datefmt='%Y-%m-%d %H:%M:%S')

            # Затем определение аргумента командной строки,
            # который должен принять путь к исследуемой директории.
            # Вместо этого следовало бы использовать argparse:
            path = sys.argv[1] if len(sys.argv) > 1 else '.'

            # Создаём экземпляр класса обработчика,
            # LoggingEventHandler - регистрирует все события:
            event_handler = LoggingEventHandler()

            # Создаём экземпляр класса обозревателя:
            observer = Observer()

            # Вызываем функцию расписания через экземпляр наблюдателя observer.schedule(),
            # передавая в неё экземпляр класса LoggingEventHandler(), он сопоставлен с переменной
            # event_handler, путь - path, который получаем через аргумент командной строки
            # и указываем, что наблюдать нужно рекурсивно:
            observer.schedule(event_handler, path, recursive=True)

            # Запускаем обозреватель:
            observer.start()
            try:
                while True:
                    observer.join(1)
            except KeyboardInterrupt:
                print('Операция завершена пользователем.')
            finally:
                observer.stop()
                observer.join()

      #+END_SRC

      Для остановки нужно нажать ~Control-c~.

*** Далее небольшой пример с Хабра:

    [[https://habr.com/ru/post/140649/][Мониторинг за изменениями файловой системы]] (внешняя ссылка).

    Здесь импортируется класс ~FileSystemEventHandler~ - базовый класс обработчика событий файловой
    системы, методы которого можно переопределить. Сам он мало, что умеет, но можно научить его
    потомка.


    #+BEGIN_SRC python

      import time   # эту строчку автор указать забыл
      from watchdog.observers import Observer
      from watchdog.events import FileSystemEventHandler

      class Handler(FileSystemEventHandler):
          def on_created(self, event):
              print event

          def on_deleted(self, event):
              print event

          def on_moved(self, event):
              print event


      # Запускаем это все:
      observer = Observer()
      observer.schedule(Handler(), path='.', recursive=True)
      observer.start()

      try:
          while True:
              time.sleep(0.1)
      except KeyboardInterrupt:
          observer.stop()
          observer.join()

    #+END_SRC

*** Следующий пример:

    Ссылка на статью от Jun 8, 2020 на английском языке -
    - [[https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c][How to Monitor File System Events in Python]]

    и ниже ссылка на её перевод от 13.06.2021

    - [[https://nuancesprog.ru/p/12757/][Как отслеживать события файловой системы в Python]]

      #+BEGIN_SRC python

        from watchdog.observers import Observer
        from watchdog.events import FileSystemEventHandler

      #+END_SRC

    Создаём новый класс, который наследуется от FileSystemEventHandler. Напомню, что
    ~FileSystemEventHandler~ предоставляет следующие функции, которые можно переопределить:

    - ~on_any_event~ - обработчик для всех событий;
    - ~on_created~ - вызывается при создании файла или каталога;
    - ~on_deleted~ - вызывается при удалении файла или каталога;
    - ~on_modified~ - вызывается при изменении файла или каталога;
    - ~on_moved~ - вызывается при перемещении или переименовании файла или каталога.


    #+BEGIN_SRC python

      class MyHandler(FileSystemEventHandler):
          def on_any_event(self, event):
              print(event.event_type, event.src_path)

          def on_created(self, event):
              print("on_created", event.src_path)

          def on_deleted(self, event):
              print("on_deleted", event.src_path)

          def on_modified(self, event):
              print("on_modified", event.src_path)

          def on_moved(self, event):
              print("on_moved", event.src_path)

    #+END_SRC

    Принты (print) можно заменить своей логикой.

    Для каждой из функций представлен входной параметр ~event~, который содержит следующие переменные:
    - ~event_type~ - тип события в виде строки. По умолчанию значение ~None~;
    - ~is_directory~ - ~true~, если событие было выдано для каталога. В противном случае - ~false~;
    - ~src_path~ - исходный путь объекта файловой системы, вызвавшего это событие.

    Наиболее полезный параметр здесь - ~src_path~.
    Им можно воспользоваться, чтобы определить, какой файл был изменен, прежде чем запускать
    соответствующую логику.

    #+BEGIN_SRC python

      if(event.src_path == "./path/file.txt"):
          print("Execute your logic here!")

    #+END_SRC

    После добавления подкласса можно безопасно создать его экземпляр вместе с классом Observer:

    #+BEGIN_SRC python

      event_handler = MyHandler()
      observer = Observer()

    #+END_SRC


    Назначим выбранный путь для процесса отслеживания. В данном случае проверим недавно созданную папку под названием ~json~.

    #+BEGIN_SRC python

      observer.schedule(event_handler, path='./json/', recursive=False)

    #+END_SRC

    Можно также установить рекурсивный параметр, но настоятельно рекомендуется предварительно
    определить иерархию и установить для нее значение ~false~, чтобы предотвратить проблемы с
    недостатком разрешений или доступом к подпапке.

    Вызов ~start~ запустит поток, и при внесении изменений в соответствующий путь будет сгенерировано
    событие.

    #+BEGIN_SRC python

      observer.start()

    #+END_SRC


    Чтобы протестировать написанный код, надо реализовать цикл выполнения и предотвратить выход из него. На выходе при возникновении исключения KeyboardInterrupt вызываем функцию ~stop~ для очистки ресурсов.

    #+BEGIN_SRC python

      while True:
          try:
              pass
          except KeyboardInterrupt:
              observer.stop()

    #+END_SRC

    Ниже идёт код целиком без комментариев:

    #+BEGIN_SRC python

      from watchdog.observers import Observer
      from watchdog.events import FileSystemEventHandler


      class MyHandler(FileSystemEventHandler):
          def on_any_event(self, event):
              print(event.event_type, event.src_path)

          def on_created(self, event):
              print("on_created", event.src_path)

          def on_deleted(self, event):
              print("on_deleted", event.src_path)

          def on_modified(self, event):
              print("on_modified", event.src_path)

          def on_moved(self, event):
              print("on_moved", event.src_path)


      event_handler = MyHandler()
      observer = Observer()

      observer.schedule(event_handler, path='./json/', recursive=False)

      observer.start()

      while True:
          try:
              pass
          except KeyboardInterrupt:
              observer.stop()

    #+END_SRC

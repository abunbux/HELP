# -*- mode: org; -*-
#+TITLE: модуль watchdog
#+DESCRIPTION:
#+KEYWORDS:
#+AUTHOR:
#+email:
#+INFOJS_OPT:
#+STARTUP:  content

#+DATE: CREATED: <Fri Jun 03 15:34:54 EEST 2022>
# Time-stamp: <Последнее обновление -- Saturday June 4 21:10:31 EEST 2022>


** Для чего нужен модуль watchdog?

   Первая строка из репозитория модуля - ~Python API and shell utilities to monitor file system
   events~ (Python API и утилиты оболочки для мониторинга событий файловой системы).

   Например:

   - Программа управления файлами для загрузки и обработки файлов, таких как изображения с SD-карты,
     или в папке ~загрузки~, например.
   - Среда разработки генератора статических сайтов следит за изменениями в исходном коде и
     перестраивает сайт при сохранении.
   - Различные задачи автоматизации дома и на рабочем месте

** Несколько полезных ссылок

   - [[https://github.com/gorakhargosh/watchdog][gorakhargosh/watchdog]] (ссылка на репозиторий разработчика на github)
   - [[https://pythonhosted.org/watchdog/index.html][watchdog 0.8.2 documentation]] (внешняя ссылка на документацию)


   - [[https://habr.com/ru/post/140649/][Мониторинг за изменениями файловой системы]] (статья о ~watchdog~ на ~habr.com~.)
   - [[https://nuancesprog.ru/p/12757/][Как отслеживать события файловой системы в Python]] (13.06.2021, перевод с английского статьи [[https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c][How
     to Monitor File System Events in Python]] от Jun 8, 2020)


   - [[https://philipkiely.com/code/python_watchdog.html][Get Started with Python Watchdog]] (09 April 2021, статья на инглиш)
   - [[https://www.geeksforgeeks.org/create-a-watchdog-in-python-to-look-for-filesystem-changes/][Create a watchdog in Python to look for filesystem changes]] (06 Dec, 2019, статья на инглиш)


   И наконец видео с сопутствующей статьёй:
   - [[https://www.youtube.com/watch?v=uFzNc7D44HI][Python на практике / Пишем 3 программы на Питон за 5 минут]] (ссылка на ~youtube~ + статья по этому
     видео [[https://itproger.com/news/pishem-3-programmi-na-python-za-paru-minut][Пишем 3 программы на Python за пару минут]])

** Послание

   Послание ~себе~ будущему и ~тебе~, мой друг, который с некоторой долей вероятности всё-таки может
   сюда попасть и прочитать, и посмеяться с моего неумелого описания:
   Некоторые термины я сейчас, возможно, употребляю неправильно. Не суди меня строго. Мне всего лишь
   48 и я ещё только учусь.

** Кратенькое руководство для моей памяти

*** Установка:

    Для начала, конечно же, библиотеку нужно установить:

    #+BEGIN_SRC shell

      pip install watchdog

    #+END_SRC

*** Устройство модуля:

    По сути ~watchdog~ состоит из двух частей:

    - Наблюдатель (~Observer~). Это класс, который отслеживает любое изменение файловой системы, а
      затем отправляет событие обработчику ~event handler~. Он контролирует файловую систему и ищет
      любые изменения;

    - Обработчик событий (~Event handler~). Это объект, который будет уведомлён, когда что-то случится
      с файловой системой и нужно произвести какое-либо действие, пусть даже и не с самим объектом
      наблюдения, можно просто сделать запись в журнал. Действие, понятное дело, нужно прописать в
      коде.

    И, следовательно, реализация состоит в следующем:

    - Создаём экземпляр класса потоков ~watchdog.observers.Observer~;

    - Определяем подкласс обработчика событий (~Event handler~) с собственной реализацией и создаём из
      него экземпляр, но справедливости ради стоит сказать, что можно обойтись и встроенной
      реализацией обработчика;

    - Вызываем функцию расписания через экземпляр наблюдателя (~observer.schedule()~), прикрепляя
      обработчик событий. Функция принимает несколько других входных параметров, таких как путь к
      отслеживаемому каталогу.

    - Запускаем поток наблюдателя и ждём, пока он сгенерирует события, которые вызовут исполнение
      кода внутри обработчика событий.

**** Обработчик событий (Event Handler)

     В настоящее время в модуле доступно 4 типа обработчиков событий:

     - ~FileSystemEventHandler~  -  базовый обработчик событий файловой системы, из которого можно
       переопределить методы;

     - ~PatternMatchingEventHandler~ - сопоставляет заданные шаблоны с путями к файлам, которые связаны с
       происходящими событиями;

     - ~RegexMatchingEventHandler~ - сопоставляет заданные регулярные выражения с путями к файлам, которые
       связаны с происходящими событиями;

     - ~LoggingEventHandler~ - регистрирует все записанные события.

       Остальные классы наследуются от ~FileSystemEventHandler~, который предоставляет для
       переопределения следующие функции:

     - ~on_any_event~ - обработчик для всех событий;
     - ~on_created~ - вызывается при создании файла или каталога;
     - ~on_deleted~ - вызывается при удалении файла или каталога;
     - ~on_modified~ - вызывается при изменении файла или каталога;
     - ~on_moved~ - вызывается при перемещении или переименовании файла или каталога.


*** Пример кода из официальной документации разработчика с моими микро-правками:

    [[https://python-watchdog.readthedocs.io/en/stable/quickstart.html#a-simple-example][A Simple Example]] (внешняя ссылка).

    Следующий пример программы будет рекурсивно отслеживать изменения файловой системы в текущем
    каталоге и просто выводить их на консоль:

    - После запуска в первозданно-скопированном виде выдаёт
    ~AttributeError: 'InotifyObserver' object has no attribute 'isAlive'~
    копаться и разбираться не стал -
    в цикле ~while~ заменил ~observer.isAlive()~ на ~True~;

    - Далее вместо принятия аргументов через ~sys.argv[1]~ лучше было бы осуществить это, импортировав
      ~argparse~;

    - Добавил ~except KeyboardInterrupt:~;

      Настроек пользователя здесь минимум, используется ~встроенный watchdog.events.LoggingEventHandler~.

      Ну, да это всего лишь пример!

      #+BEGIN_SRC python

        import sys
        import logging
        from watchdog.observers import Observer
        from watchdog.events import LoggingEventHandler

        if __name__ == "__main__":
            # Сперва идут настройки логирования модуля logging:
            logging.basicConfig(level=logging.INFO,
                                format='%(asctime)s - %(message)s',
                                datefmt='%Y-%m-%d %H:%M:%S')

            # Затем определение аргумента командной строки,
            # который должен принять путь к исследуемой директории.
            # Вместо этого следовало бы использовать argparse:
            path = sys.argv[1] if len(sys.argv) > 1 else '.'

            # Создаём экземпляр класса обработчика,
            # LoggingEventHandler - регистрирует все события:
            event_handler = LoggingEventHandler()

            # Создаём экземпляр класса обозревателя:
            observer = Observer()

            # Вызываем функцию расписания через экземпляр наблюдателя observer.schedule(),
            # передавая в неё экземпляр класса LoggingEventHandler(), он сопоставлен с переменной
            # event_handler, путь - path, который получаем через аргумент командной строки
            # и указываем, что наблюдать нужно рекурсивно:
            observer.schedule(event_handler, path, recursive=True)

            # Запускаем обозреватель:
            observer.start()
            try:
                while True:
                    observer.join(1)
            except KeyboardInterrupt:
                print('Операция завершена пользователем.')
            finally:
                observer.stop()
                observer.join()

      #+END_SRC

      Для остановки нужно нажать ~Control-c~.

*** Далее небольшой пример с Хабра:

    [[https://habr.com/ru/post/140649/][Мониторинг за изменениями файловой системы]] (внешняя ссылка, она также присутствует в тексте выше.

    Здесь импортируется класс ~FileSystemEventHandler~ - базовый класс обработчика событий файловой
    системы, методы которого можно переопределить. Сам он мало, что умеет, но можно научить его
    потомка.


    #+BEGIN_SRC python

      import time   # эту строчку автор указать забыл
      from watchdog.observers import Observer
      from watchdog.events import FileSystemEventHandler

      class Handler(FileSystemEventHandler):
          def on_created(self, event):
              print event

          def on_deleted(self, event):
              print event

          def on_moved(self, event):
              print event


      # Запускаем это все:
      observer = Observer()
      observer.schedule(Handler(), path='.', recursive=True)
      observer.start()

      try:
          while True:
              time.sleep(0.1)
      except KeyboardInterrupt:
          observer.stop()
          observer.join()

    #+END_SRC

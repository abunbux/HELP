# -*- mode: org; -*-
#+TITLE: ${1:$$(file-name-base)}
#+DESCRIPTION:
#+KEYWORDS:
#+AUTHOR:
#+email:
#+INFOJS_OPT:
#+STARTUP:  content

#+DATE: `(my/insert-current-date-time)`
# Time-stamp: <Последнее обновление -- Monday July 26 22:47:9 EEST 2021>



~grep~ это вполне возможно самая популярная из существующих команд в Unix/Linux. Многие бы с этим поспорили, но стоит начать использовать grep, эта команда будет присутствовать почти во всех ваших скриптах для консоли Linux. grep расшифровывается как global ~regular expression printer~. Иными словами grep выдрезает нужные вам строки из текстовых файлов которые содержат указаный пользователем текст.
grep может быть использован двумя путями - сам по себе или в комбинации с потоками.

* Использование grep в чистом виде

  Эта команда показывает как можно использовать grep для того чтобы получить строки из файла содержащие подстроку указаную в командной строке. Файл не обязательно должен оканчиваться на .txt. Показаная выше команда производит поиск подстроки 12.00 в файле /home/david/backup/log.txt и отображает все строки где эта подстрока встречается.
  #+BEGIN_SRC shell
    $ grep '12:00' /home/david/backup/log.txt
  #+END_SRC


  Эта комбинация может быть использована например для поиска бекапов которые происходили в 12:00.
  #+BEGIN_SRC shell
    $ grep -v '12.00' /home/david/backup/log.txt
  #+END_SRC

  А вот эта команда (с использованием ключа -v) наоборот покажет только те строки где подстрока ’12:00′ не встречается.
  #+BEGIN_SRC shell
    $ grep -l 'delay' /code/*.c
  #+END_SRC

  Эта команда будет искать все файлы оканчивающиеся на .c и текст в найденых файлах соответствующий подстроке 'delay' и в конечном итоге выведет только имена файлов где эта подстрока встречается.
  #+BEGIN_SRC shell
    $ grep -w '\<bay' *
    $ grep -w 'watch\>' *
  #+END_SRC

  Эта команда уже более сложная и состоит из комбинации двух команд grep. Первая ищет строки которые начинаются со слова ‘bay’ а вторая строки которые заканчиваются на слово ‘watch’.

* Использование grep вместе с потоками

  #+BEGIN_SRC shell
    $ ls -l | grep rwxrwxrwx
  #+END_SRC

  Вы наверно уже знаете что команда ls -l отображает подробный список файлов в директории. Часть grep rwxrwxrwxфильтрует результат полученый от ls -l и выводит только те директории у которых установлены соответствующие права доступа. В данном случае это открытый доступ на чтение, запись и поиск для всех пользователей и групп. Так что вместо того чтобы увидеть полный список файлов вы увидите только те файлы у которых установлены нужные вам права доступа.
  Вывод от команды grep может также быть направлен потоком в другую команду, например как в следующем примере:
  #+BEGIN_SRC shell
    $ du | grep 'mp3' | more
  #+END_SRC

  Вы должны уже догадаться что делает указаная выше команда  Если не догадались то все просто - она выводит постранично список mp3 файлов найденых в текущей директории. Все просто
  #+BEGIN_SRC shell
    $ grep '^#' /home/david/script1 | more
  #+END_SRC

  Эта команда отобразит все строки в файле /home/david/script1 которые начинаются с символа ~#~. Определение тип ~^#~ означает что символ ~#~ должен быть первым символом с троке.
  #+BEGIN_SRC shell
    $ grep -v '^[0-9]' /home/david/bac
  #+END_SRC

* Поиск наоборот

  Что, если вы хотите найти всё, кроме чего-то? grep умеет и это тоже. Используйте опцию ~-v~ и grep будет выводить только те строки, которые не соответствуютшаблону.
  Если вы хотите, чтобы grep отобразила лишь имена файлов, не содержащихстроки, соответствующие шаблону, при это не выводя сами строки, используйте опцию ~-L~.
  Напротив, если вам нужны только имена файлов, в которых соответствия шаблону найдены, но сами строки вам не нужны, используйте опцию ~-l~.
  Само собой, вы можете комбинировать опции. Например, чтобы найти файлы, не содержащие строк, соответствующих шаблону можно использовать
  #+BEGIN_SRC shell
    $ grep -v -l pattern *
  #+END_SRC

  Вам не нужны имена файлов в выводе grep, а интересны лишь строки - воспользуйтесь опцией ~-h~ и grep не будет выводить имена файлов.
  По умолчанию grep выполняет ~жадный~ поиск. То есть, она захватывает не только часть строки, соответствующую шаблону, но и всё после неё. Например,
  если вы ищете «Beat», то grep будет считать соответствием и «Beatles», «Beaten», «Beats» и любую строку, содержащую «Beat». Такое поведение grep на
  практике нечасто пригождается и вы можете ограничить его при помощи опции ~-w~. С этой опцией grep будет отбирать соответствия в пределах слова.

* Контекст

  В процессе поиска по лог-файлам часто нужно увидеть, в каком контексте найдено то или иное. По умолчанию grep выводит лишь строку, в которой было найдено совпадение, но есть несколько опций, позволяющих заставить grep выводить больше: ~-A~ (после контекста),  ~-B~ (перед контекстом) и ~-C~ (контекст).
  Используя эти опции, необходимо указать саму опцию и целое число, определяющее количество строк для вывода. Например
  #+BEGIN_SRC shell
    $ grep -C 2 pattern files
  #+END_SRC
  выведет строки, в которых найдено соответствие, плюс 2 строки до 2 после каждой найденной.

* Регулярные выражения
  grep может оказаться совершенно неиспользуемой в повседневной жизни, если вы собираетесь при помощи неё искать лишь какие-то конкретные последовательности символов. А как быть с тем, если вам нужно найти, например, только цифры или последовательность символов, в которую могут входить лишь определённые символы или их группы? Не проблема! Используя регулярные выражения  в grep, вы получаете инструмент для решения чуть ли не любой задачи поиска.
  Давайте немного рассмотрим регулярные выражения, которые, вероятно, вам пригодятся. В командной оболочке символ звёздочки ~*~ соответствует любому символу ноль или более раз. В grep символ ~*~ имеет несколько иное значение. В grep этот символ необходимо группировать с другими. Например, если вам нужен тот же эффект, как и в оболочке, используйте следующее:
  #+BEGIN_SRC shell
    $ grep '.*' pattern files
  #+END_SRC

  Если вам необходимо определить какой-то шаблон один и более раз, вы можете использовать конструкцию ~+шаблон~.
  Символ ~^~ соответствует началу строки, а символ ~$~ - её концу. Например, вы хотите найти все файлы с расширением «.html», но вам не нужны файлы с расширением «.html.bak»:
  #+BEGIN_SRC shell
    $ ls | grep '.*html$'
  #+END_SRC

  Если вам необходимо, чтобы grep интерпретировала спецсивмолы как обычные - предварите их обратным слешем. Например
  #+BEGIN_SRC shell
    $ grep '\*' filename
  #+END_SRC
  будет искать строки, содержащие символ звёздочки в filename.

  В выражениях можно использовать диапазоны и классы символов. Для этого при составлении шаблона в grep используются квадратные скобки. Например,
  символу в диапазоне от A до Z будет соответствовать шаблон ~[A-Z]""~,
  а любой цифре - ~[0-9]""~.
  Также, используя квадратные скобки вы можете определять соответствиеклассам символов.
  Например, ~[:punct:]""~ будет соответствовать любому знаку препинания.
  Например, чтобы найти строки, содержащие знаки препинания в конце, можно использовать следующую команду:
  #+BEGIN_SRC shell
    $ grep '[[:punct:]]$' files
  #+END_SRC

  Обратите внимание на двойные скобки. Вообще, об использовании регулярных выражений в grep лучше всего проконсультируйтесь с её man-страницей . Поначалу, понимание того, что написано там, может даваться вам с некоторым трудом, однако не поленитесь, и вы сможете овладеть мощным инструментом - регулярными выражениями.

* Цвета

  Зачастую в выводе grep трудновато бывает сразу же отыскать соответствующую шаблону часть строки. Чтобы упростить задачу визуального поиска среди результатов выдачи grep, вы можете попросить её использовать цвет для отметки совпадений. Просто добавьте опцию ~--color=always~ или ~--color=auto~!
  Обратите внимание, что в некоторых дистрибутивах разработчики создают псевдоним для grep, включающий цвет по умолчанию. Например, в Linux Mint команда ~grep~ имеет псевдоним ~grep --color=auto~. Если у вас похожая ситуация, то используйте команду ~grep --color=off~ в случаях, когда вам не нужен «цветной» вывод.
  С цветом или без, grep - утилита, без которой себе не представляют жизни ни «продвинутые пользователи», ни системные администраторы. Конечно, рядовым пользователям десктопов знание этой утилиты может оказаться вовсе ни к чему, хотя и не будет большого вреда, если они с ней познакомятся. Но если же вы собираетесь работать в Linux на более высоком уровне, то grep - это одна из первых вещей, которые вам стоит освоить.
